package org.example.Multithread.LifeCycle;import static java.lang.Thread.sleep;public class lifecycle extends Thread {    @Override    public void run() {        System.out.println("Run method is executed.So State  is  RUNNING");        try {            Thread.sleep(3000); // when we do sleep it mopves the STATE to  TIMED_WAITING            // meaning its waiting for the time to be over.        } catch (InterruptedException e) {            throw new RuntimeException(e);        }    }    public static void main(String[] args) throws InterruptedException {        lifecycle lc = new lifecycle();        System.out.println("The State is : "+ lc.getState());//STATE -NEW--When Thread is Created        lc.start();        System.out.println("The State now is : "+ lc.getState());//STATE - RUNNABLE-- When the Thread is reday to run.        //putting the main thjread to sleep for 100 ms so lc thread is now in action.        sleep(100);        //State of the ls thread        System.out.println("State of the "+Thread.currentThread().getName()+" thread :"+ Thread.currentThread().getState());        System.out.println("The State after Sleep odf LC thread is : "+ lc.getState());        //Now since the Main thread is running and lc thread is sleeping so join will make main to wait for        lc.join();        System.out.println("The State after join of LC thread is : "+ lc.getState());    }}
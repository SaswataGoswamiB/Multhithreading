package org.example.Multithread.Lock;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class BankAccountExplicit {    private int balance = 1000;    //lock class impl    private final Lock lock = new ReentrantLock();    public void withdraw(int amount) throws InterruptedException {        System.out.println(Thread.currentThread().getName() + "attempting to withdraw " + amount);        // Here the thread will try to wait for 2 sec to acquire the lock if it acquies it gives true else false        //Here the thread will not wait for any time to get the result        if (lock.tryLock(2, TimeUnit.SECONDS)) {            try {                System.out.println("Account  Acquired by : " + Thread.currentThread().getName());                if (balance >= amount) {                    Thread.sleep(10000);                    balance = balance - amount;                    System.out.println("Balance  : " + (balance - amount));                }            } catch (Exception e) {                e.printStackTrace();                // its the good practice to interrupt the thread in the catch block                Thread.currentThread().interrupt();            } finally {                lock.unlock();            }        } else {            System.out.println(Thread.currentThread().getName() + "  could not acquire the lock.Will try again later.....");        }    }}